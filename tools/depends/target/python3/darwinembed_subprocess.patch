--- a/Lib/subprocess.py
+++ b/Lib/subprocess.py
@@ -737,6 +737,8 @@
                  restore_signals=True, start_new_session=False,
                  pass_fds=(), *, encoding=None, errors=None, text=None):
         """Create new Popen instance."""
+        raise RuntimeError("Subprocesses are not supported on this platform.")
+
         _cleanup()
         # Held while anything is calling waitpid before returncode has been
         # updated to prevent clobbering returncode if wait() or poll() are
@@ -936,6 +936,7 @@
         if not self._child_created:
             # We didn't get to successfully create a child process.
             return
+        return
         if self.returncode is None:
             # Not reading subprocess exit status creates a zombie process which
             # is only destroyed at the parent python process exit
@@ -1566,6 +1566,7 @@
             else:
                 args = list(args)
 
+            shell = False
             if shell:
                 # On Android the default shell is at '/system/bin/sh'.
                 unix_shell = ('/system/bin/sh' if
@@ -1643,6 +1643,7 @@
                             errpipe_read, errpipe_write,
                             restore_signals, start_new_session, preexec_fn)
                     self._child_created = True
+                    return
                 finally:
                     # be sure the FD is closed no matter what
                     os.close(errpipe_write)
@@ -1662,6 +1662,7 @@
             finally:
                 # be sure the FD is closed no matter what
                 os.close(errpipe_read)
+                return
 
             if errpipe_data:
                 try:
@@ -1721,7 +1724,7 @@
                 raise SubprocessError("Unknown child exit status!")
 
 
-        def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
+        def _internal_poll(self, _deadstate=None, _waitpid=None,
                 _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
             """Check if child process has terminated.  Returns returncode
             attribute.
@@ -1730,6 +1733,8 @@
             outside of the local scope (nor can any methods it calls).
 
             """
+            if _waitpid is None:
+                _waitpid = os.waitpid
             if self.returncode is None:
                 if not self._waitpid_lock.acquire(False):
                     # Something else is busy calling waitpid.  Don't allow two
--- a/Modules/_posixsubprocess.c
+++ b/Modules/_posixsubprocess.c
@@ -49,6 +49,9 @@
 
 #define POSIX_CALL(call)   do { if ((call) == -1) goto error; } while (0)
 
+#if defined(__APPLE__)
+#include <TargetConditionals.h>
+#endif
 
 /* If gc was disabled, call gc.enable().  Return 0 on success. */
 static int
@@ -419,14 +422,14 @@
         goto error;
 
     /* Close parent's pipe ends. */
-    if (p2cwrite != -1)
+/*    if (p2cwrite != -1)
         POSIX_CALL(close(p2cwrite));
     if (c2pread != -1)
         POSIX_CALL(close(c2pread));
     if (errread != -1)
         POSIX_CALL(close(errread));
     POSIX_CALL(close(errpipe_read));
-
+*/
     /* When duping fds, if there arises a situation where one of the fds is
        either 0, 1 or 2, it is possible that it is overwritten (#12607). */
     if (c2pwrite == 0) {
@@ -471,6 +474,8 @@
     /* We no longer manually close p2cread, c2pwrite, and errwrite here as
      * _close_open_fds takes care when it is not already non-inheritable. */
 
+    const char *currentDir = getcwd(NULL, 0);
+
     if (cwd)
         POSIX_CALL(chdir(cwd));
 
@@ -496,13 +501,13 @@
             errno = 0;  /* We don't want to report an OSError. */
             goto error;
         }
-        /* Py_DECREF(result); - We're about to exec so why bother? */
+        Py_DECREF(result); /* - We're about to exec so why bother? */
     }
 
     /* close FDs after executing preexec_fn, which might open FDs */
     if (close_fds) {
         /* TODO HP-UX could use pstat_getproc() if anyone cares about it. */
-        _close_open_fds(3, py_fds_to_keep);
+//        _close_open_fds(3, py_fds_to_keep);
     }
 
     /* This loop matches the Lib/os.py _execvpe()'s PATH search when */
@@ -511,20 +516,34 @@
     for (i = 0; exec_array[i] != NULL; ++i) {
         const char *executable = exec_array[i];
         if (envp) {
+#if defined(TARGET_OS_TV)
+            saved_errno = ENOTSUP;
+#elif defined(TARGET_OS_IOS)
             execve(executable, argv, envp);
+            saved_errno = execve(executable, argv, envp);
+#endif
+            break;
         } else {
+#if defined(TARGET_OS_TV)
+            saved_errno = ENOTSUP;
+#elif defined(TARGET_OS_IOS)
             execv(executable, argv);
+            saved_errno = execv(executable, argv);
+#endif
+            break;
         }
         if (errno != ENOENT && errno != ENOTDIR && saved_errno == 0) {
             saved_errno = errno;
         }
     }
+    if (saved_errno == 0) return;
     /* Report the first exec error, not the last. */
     if (saved_errno)
         errno = saved_errno;
 
 error:
     saved_errno = errno;
+    chdir(currentDir);
     /* Report the posix error to our parent process. */
     /* We ignore all write() return values as the total size of our writes is
        less than PIPEBUF and we cannot do anything about an error anyways.
@@ -686,11 +705,12 @@
         preexec_fn_args_tuple = PyTuple_New(0);
         if (!preexec_fn_args_tuple)
             goto cleanup;
-        PyOS_BeforeFork();
+//        PyOS_BeforeFork();
         need_after_fork = 1;
     }
 
-    pid = fork();
+    pid = -1;
+    errno = ENOTSUP;
     if (pid == 0) {
         /* Child process */
         /*
@@ -704,7 +724,7 @@
              * This call may not be async-signal-safe but neither is calling
              * back into Python.  The user asked us to use hope as a strategy
              * to avoid deadlock... */
-            PyOS_AfterFork_Child();
+//            PyOS_AfterFork_Child();
         }
 
         child_exec(exec_array, argv, envp, cwd,
@@ -723,8 +743,8 @@
 
     Py_XDECREF(cwd_obj2);
 
-    if (need_after_fork)
-        PyOS_AfterFork_Parent();
+//    if (need_after_fork)
+//        PyOS_AfterFork_Parent();
     if (envp)
         _Py_FreeCharPArray(envp);
     if (argv)
