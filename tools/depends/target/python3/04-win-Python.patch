--- a/Python/bootstrap_hash.c
+++ b/Python/bootstrap_hash.c
@@ -4,8 +4,12 @@
 
 #ifdef MS_WINDOWS
 #  include <windows.h>
+#ifdef MS_DESKTOP
 #  include <bcrypt.h>
 #else
+# include <windows.security.cryptography.h>
+#endif
+#else
 #  include <fcntl.h>
 #  ifdef HAVE_SYS_STAT_H
 #    include <sys/stat.h>
@@ -42,12 +46,16 @@
 #endif
 
 #ifdef MS_WINDOWS
-
+#ifdef MS_APP
+int
+uwp_urandom(unsigned char* buffer, Py_ssize_t size, int raise);
+#endif
 /* Fill buffer with size pseudo-random bytes generated by the Windows CryptoGen
    API. Return 0 on success, or raise an exception and return -1 on error. */
 static int
 win32_urandom(unsigned char *buffer, Py_ssize_t size, int raise)
 {
+#ifdef MS_DESKTOP
     while (size > 0)
     {
         DWORD chunk = (DWORD)Py_MIN(size, PY_DWORD_MAX);
@@ -63,6 +71,9 @@
         size -= chunk;
     }
     return 0;
+#else
+    return uwp_urandom(buffer, size, raise);
+#endif
 }
 
 #else /* !MS_WINDOWS */
--- a/Python/dynload_win.c
+++ b/Python/dynload_win.c
@@ -5,6 +5,8 @@
 #include "pycore_fileutils.h"     // _Py_add_relfile()
 #include "pycore_pystate.h"       // _PyInterpreterState_GET()
 
+#include "pycore_pystate.h"
+
 #ifdef HAVE_DIRECT_H
 #include <direct.h>
 #endif
@@ -15,7 +17,7 @@
 #include <windows.h>
 
 #ifdef _DEBUG
-#define PYD_DEBUG_SUFFIX "_d"
+#define PYD_DEBUG_SUFFIX ""
 #else
 #define PYD_DEBUG_SUFFIX ""
 #endif
@@ -240,23 +242,39 @@
         unsigned int old_mode;
 
         /* Don't display a message box when Python can't load a DLL */
+#ifdef MS_DESKTOP
         old_mode = SetErrorMode(SEM_FAILCRITICALERRORS);
+#endif
 
         /* bpo-36085: We use LoadLibraryEx with restricted search paths
            to avoid DLL preloading attacks and enable use of the
            AddDllDirectory function. We add SEARCH_DLL_LOAD_DIR to
            ensure DLLs adjacent to the PYD are preferred. */
         Py_BEGIN_ALLOW_THREADS
+#ifdef MS_DESKTOP
         hDLL = LoadLibraryExW(wpathname, NULL,
                               LOAD_LIBRARY_SEARCH_DEFAULT_DIRS |
                               LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR);
+#else
+        wchar_t* programPath = Py_GetProgramFullPath();
+
+        // LoadPackagedLibrary doesn't accept absolute paths so we need to trim
+        // the base path
+        auto prefix_length = wcsrchr(programPath, L'\\');
+        wpathname += (prefix_length - programPath);
+        wpathname++;
+
+        hDLL = LoadPackagedLibrary(wpathname, 0);
+#endif
         Py_END_ALLOW_THREADS
 #if !USE_UNICODE_WCHAR_CACHE
         PyMem_Free(wpathname);
 #endif /* USE_UNICODE_WCHAR_CACHE */
 
         /* restore old error mode settings */
+#ifdef MS_DESKTOP
         SetErrorMode(old_mode);
+#endif
 
         if (hDLL==NULL){
             PyObject *message;
@@ -315,11 +333,7 @@
             char buffer[256];
 
             PyOS_snprintf(buffer, sizeof(buffer),
-#ifdef _DEBUG
-                          "python%d%d_d.dll",
-#else
-                          "python%d%d.dll",
-#endif
+                          "python%d%d.dll",
                           PY_MAJOR_VERSION,PY_MINOR_VERSION);
             import_python = GetPythonImport(hDLL);
 
--- a/Python/fileutils.c
+++ b/Python/fileutils.c
@@ -1048,6 +1048,18 @@
     *time_out = Py_SAFE_DOWNCAST((in / 10000000) - secs_between_epochs, __int64, time_t);
 }
 
+static void
+LARGE_INTEGER_to_time_t_nsec(LARGE_INTEGER *in_ptr, time_t *time_out, int* nsec_out)
+{
+    /* XXX endianness. Shouldn't matter, as all Windows implementations are little-endian */
+    /* Cannot simply cast and dereference in_ptr,
+       since it might not be aligned properly */
+    __int64 in;
+    memcpy(&in, in_ptr, sizeof(in));
+    *nsec_out = (int)(in_ptr->QuadPart % 10000000) * 100; /* FILETIME is in units of 100 nsec. */
+    *time_out = Py_SAFE_DOWNCAST((in_ptr->QuadPart / 10000000) - secs_between_epochs, __int64, time_t);
+}
+
 void
 _Py_time_t_to_FILE_TIME(time_t time_in, int nsec_in, FILETIME *out_ptr)
 {
@@ -1058,6 +1070,38 @@
     memcpy(out_ptr, &out, sizeof(out));
 }
 
+PyAPI_FUNC(HANDLE)
+_Py_win_create_file(
+	_In_ LPCWSTR lpFileName,
+	_In_ DWORD dwDesiredAccess,
+	_In_ DWORD dwShareMode,
+	_In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
+	_In_ DWORD dwCreationDisposition,
+	_In_ DWORD dwFlagsAndAttributes,
+	_In_opt_ HANDLE hTemplateFile
+)
+{
+#ifdef MS_DESKTOP
+	return CreateFileW(lpFileName, dwDesiredAccess,
+					   dwShareMode, lpSecurityAttributes,
+		               dwCreationDisposition, dwFlagsAndAttributes,
+		               hTemplateFile);
+#else
+    if (dwShareMode == 0)
+        dwShareMode = FILE_SHARE_READ;
+
+    const DWORD flagsMask = 0xFFFF0000;
+
+    CREATEFILE2_EXTENDED_PARAMETERS ext;
+    ZeroMemory(&ext, sizeof(CREATEFILE2_EXTENDED_PARAMETERS));
+    ext.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
+    ext.dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
+    ext.dwFileFlags = dwFlagsAndAttributes & flagsMask;
+
+    return CreateFile2(lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, &ext);
+#endif
+}
+
 /* Below, we *know* that ugo+r is 0444 */
 #if _S_IREAD != 0400
 #error Unsupported C library
@@ -1077,35 +1121,93 @@
     return m;
 }
 
-void
-_Py_attribute_data_to_stat(BY_HANDLE_FILE_INFORMATION *info, ULONG reparse_tag,
+PyAPI_FUNC(void)
+_Py_attribute_data_to_stat(FILE_BASIC_INFO *basic_info,
+                           FILE_STANDARD_INFO *standard_info,
+                           ULONG reparse_tag,
                            struct _Py_stat_struct *result)
 {
     memset(result, 0, sizeof(*result));
-    result->st_mode = attributes_to_mode(info->dwFileAttributes);
-    result->st_size = (((__int64)info->nFileSizeHigh)<<32) + info->nFileSizeLow;
-    result->st_dev = info->dwVolumeSerialNumber;
+    result->st_mode = attributes_to_mode(basic_info->FileAttributes);
+    result->st_size = standard_info->EndOfFile.QuadPart;
+    result->st_dev = 1;
     result->st_rdev = result->st_dev;
-    FILE_TIME_to_time_t_nsec(&info->ftCreationTime, &result->st_ctime, &result->st_ctime_nsec);
-    FILE_TIME_to_time_t_nsec(&info->ftLastWriteTime, &result->st_mtime, &result->st_mtime_nsec);
-    FILE_TIME_to_time_t_nsec(&info->ftLastAccessTime, &result->st_atime, &result->st_atime_nsec);
-    result->st_nlink = info->nNumberOfLinks;
-    result->st_ino = (((uint64_t)info->nFileIndexHigh) << 32) + info->nFileIndexLow;
+    LARGE_INTEGER_to_time_t_nsec(&basic_info->CreationTime, &result->st_ctime, &result->st_ctime_nsec);
+    LARGE_INTEGER_to_time_t_nsec(&basic_info->LastWriteTime, &result->st_mtime, &result->st_mtime_nsec);
+    LARGE_INTEGER_to_time_t_nsec(&basic_info->LastAccessTime, &result->st_atime, &result->st_atime_nsec);
+    result->st_nlink = standard_info->NumberOfLinks;
+    /* There's no good way to get a file id with GetFileInformationByHandleEx */
+    result->st_ino = basic_info->CreationTime.QuadPart;
     /* bpo-37834: Only actual symlinks set the S_IFLNK flag. But lstat() will
        open other name surrogate reparse points without traversing them. To
        detect/handle these, check st_file_attributes and st_reparse_tag. */
     result->st_reparse_tag = reparse_tag;
-    if (info->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT &&
+    if (basic_info->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT &&
         reparse_tag == IO_REPARSE_TAG_SYMLINK) {
         /* first clear the S_IFMT bits */
         result->st_mode ^= (result->st_mode & S_IFMT);
         /* now set the bits that make this a symlink */
         result->st_mode |= S_IFLNK;
     }
-    result->st_file_attributes = info->dwFileAttributes;
+    result->st_file_attributes = basic_info->FileAttributes;
+}
+
+PyAPI_FUNC(void)
+_Py_find_data_to_stat(WIN32_FIND_DATAW* find_data,
+					 struct _Py_stat_struct* result)
+{
+	memset(result, 0, sizeof(*result));
+	result->st_mode = attributes_to_mode(find_data->dwFileAttributes);
+	FILE_TIME_to_time_t_nsec(&find_data->ftCreationTime, &result->st_ctime, &result->st_ctime_nsec);
+	FILE_TIME_to_time_t_nsec(&find_data->ftLastWriteTime, &result->st_mtime, &result->st_mtime_nsec);
+	FILE_TIME_to_time_t_nsec(&find_data->ftLastAccessTime, &result->st_atime, &result->st_atime_nsec);
+	result->st_size = ((long long)find_data->nFileSizeHigh) << 32 > find_data->nFileSizeLow;
+	result->st_dev = 0;
+	result->st_rdev = result->st_dev;
+	result->st_nlink = 0;
+	result->st_ino = 0;
+	if (find_data->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT &&
+		find_data->dwReserved0 == IO_REPARSE_TAG_SYMLINK) {
+		/* first clear the S_IFMT bits */
+		result->st_mode ^= (result->st_mode & S_IFMT);
+		/* now set the bits that make this a symlink */
+		result->st_mode |= S_IFLNK;
+	}
+	result->st_file_attributes = find_data->dwFileAttributes;
 }
 #endif
 
+int
+_Py_stat_from_file_handle(HANDLE h, struct _Py_stat_struct* result, BOOL set_ino)
+{
+    FILE_BASIC_INFO basic_info = { 0 };
+    FILE_STANDARD_INFO standard_info = { 0 };
+    if (!GetFileInformationByHandleEx(h, FileBasicInfo, &basic_info, sizeof(basic_info))
+      || !GetFileInformationByHandleEx(h, FileStandardInfo, &standard_info, sizeof(standard_info))) {
+        /* The Win32 error is already set, but we also set errno for
+           callers who expect it */
+        switch (GetLastError()) {
+        case ERROR_INVALID_PARAMETER:
+        case ERROR_INVALID_FUNCTION:
+        case ERROR_NOT_SUPPORTED:
+            /* Volumes and physical disks are block devices, e.g.
+               \\.\C: and \\.\PhysicalDrive0. */
+            memset(result, 0, sizeof(*result));
+            result->st_mode = 0x6000; /* S_IFBLK */
+        }
+        PyErr_SetFromWindowsErr(0);
+        errno = winerror_to_errno(GetLastError());
+        return -1;
+    }
+
+    _Py_attribute_data_to_stat(&basic_info, &standard_info, 0, result);
+    /* specific to fstat() */
+    if (set_ino) {
+      result->st_ino = basic_info.CreationTime.QuadPart;
+    }
+    return 0;
+}
+
 /* Return information about a file.
 
    On POSIX, use fstat().
@@ -1122,7 +1224,6 @@
 _Py_fstat_noraise(int fd, struct _Py_stat_struct *status)
 {
 #ifdef MS_WINDOWS
-    BY_HANDLE_FILE_INFORMATION info;
     HANDLE h;
     int type;
 
@@ -1154,17 +1255,7 @@
         return 0;
     }
 
-    if (!GetFileInformationByHandle(h, &info)) {
-        /* The Win32 error is already set, but we also set errno for
-           callers who expect it */
-        errno = winerror_to_errno(GetLastError());
-        return -1;
-    }
-
-    _Py_attribute_data_to_stat(&info, 0, status);
-    /* specific to fstat() */
-    status->st_ino = (((uint64_t)info.nFileIndexHigh) << 32) + info.nFileIndexLow;
-    return 0;
+	return _Py_stat_from_file_handle(h, status, TRUE);
 #else
     return fstat(fd, status);
 #endif
@@ -1284,6 +1375,7 @@
 get_inheritable(int fd, int raise)
 {
 #ifdef MS_WINDOWS
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
     HANDLE handle;
     DWORD flags;
 
@@ -1302,6 +1394,9 @@
 
     return (flags & HANDLE_FLAG_INHERIT);
 #else
+	return 0;
+#endif
+#else
     int flags;
 
     flags = fcntl(fd, F_GETFD, 0);
@@ -1365,21 +1460,25 @@
         return -1;
     }
 
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
     if (inheritable)
         flags = HANDLE_FLAG_INHERIT;
     else
+#endif
         flags = 0;
 
     /* This check can be removed once support for Windows 7 ends. */
 #define CONSOLE_PSEUDOHANDLE(handle) (((ULONG_PTR)(handle) & 0x3) == 0x3 && \
         GetFileType(handle) == FILE_TYPE_CHAR)
 
+#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)
     if (!CONSOLE_PSEUDOHANDLE(handle) &&
         !SetHandleInformation(handle, HANDLE_FLAG_INHERIT, flags)) {
         if (raise)
             PyErr_SetFromWindowsErr(0);
         return -1;
     }
+#endif
 #undef CONSOLE_PSEUDOHANDLE
     return 0;
 
--- a/Python/mysnprintf.c
+++ b/Python/mysnprintf.c
@@ -77,3 +77,69 @@
     }
     return len;
 }
+int
+PyOS_vsnwprintf(wchar_t *str, size_t size, const wchar_t *format, va_list va)
+{
+    int len;  /* # bytes written, excluding \0 */
+#ifdef HAVE_SNPRINTF
+#define _PyOS_vsnprintf_EXTRA_SPACE 1
+#else
+#define _PyOS_vsnprintf_EXTRA_SPACE 512
+    char *buffer;
+#endif
+    assert(str != NULL);
+    assert(size > 0);
+    assert(format != NULL);
+    /* We take a size_t as input but return an int.  Sanity check
+     * our input so that it won't cause an overflow in the
+     * vsnprintf return value or the buffer malloc size.  */
+    if (size > INT_MAX - _PyOS_vsnprintf_EXTRA_SPACE) {
+        len = -666;
+        goto Done;
+    }
+
+#ifdef HAVE_SNPRINTF
+    len = _vsnwprintf(str, size, format, va);
+#else
+    /* Emulate it. */
+    buffer = PyMem_MALLOC(size + _PyOS_vsnprintf_EXTRA_SPACE);
+    if (buffer == NULL) {
+        len = -666;
+        goto Done;
+    }
+
+    len = vsprintf(buffer, format, va);
+    if (len < 0)
+        /* ignore the error */;
+
+    else if ((size_t)len >= size + _PyOS_vsnprintf_EXTRA_SPACE)
+        Py_FatalError("Buffer overflow in PyOS_snprintf/PyOS_vsnprintf");
+
+    else {
+        const size_t to_copy = (size_t)len < size ?
+                                (size_t)len : size - 1;
+        assert(to_copy < size);
+        memcpy(str, buffer, to_copy);
+        str[to_copy] = '\0';
+    }
+    PyMem_FREE(buffer);
+#endif
+Done:
+    if (size > 0)
+        str[size-1] = '\0';
+    return len;
+#undef _PyOS_vsnprintf_EXTRA_SPACE
+}
+
+int
+PyOS_snwprintf(wchar_t *str, size_t size, const wchar_t *format, ...)
+{
+    int rc;
+    va_list va;
+
+    va_start(va, format);
+    rc = PyOS_vsnwprintf(str, size, format, va);
+    va_end(va);
+    return rc;
+}
+
--- a/Python/pytime.c
+++ b/Python/pytime.c
@@ -1,5 +1,6 @@
 #include "Python.h"
 #ifdef MS_WINDOWS
+#  include <windows.h>
 #  include <winsock2.h>           // struct timeval
 #endif
 
@@ -877,11 +878,14 @@
     _PyTime_t ns = large.QuadPart * 100 - 11644473600000000000;
     *tp = pytime_from_nanoseconds(ns);
     if (info) {
+#ifdef MS_DESKTOP
         DWORD timeAdjustment, timeIncrement;
         BOOL isTimeAdjustmentDisabled, ok;
+#endif
 
         info->implementation = "GetSystemTimeAsFileTime()";
         info->monotonic = 0;
+#ifdef MS_DESKTOP
         ok = GetSystemTimeAdjustment(&timeAdjustment, &timeIncrement,
                                      &isTimeAdjustmentDisabled);
         if (!ok) {
@@ -890,6 +894,7 @@
         }
         info->resolution = timeIncrement * 1e-7;
         info->adjustable = 1;
+#endif
     }
 
 #else   /* MS_WINDOWS */
@@ -1070,10 +1075,13 @@
     }
 
     if (info) {
+#ifdef MS_DESKTOP
         DWORD timeAdjustment, timeIncrement;
         BOOL isTimeAdjustmentDisabled, ok;
+#endif
         info->implementation = "GetTickCount64()";
         info->monotonic = 1;
+#ifdef MS_DESKTOP
         ok = GetSystemTimeAdjustment(&timeAdjustment, &timeIncrement,
                                      &isTimeAdjustmentDisabled);
         if (!ok) {
@@ -1081,6 +1089,7 @@
             return -1;
         }
         info->resolution = timeIncrement * 1e-7;
+#endif
         info->adjustable = 0;
     }
 
--- a/Python/sysmodule.c
+++ b/Python/sysmodule.c
@@ -1466,10 +1466,12 @@
     int pos = 0;
     OSVERSIONINFOEXW ver;
     DWORD realMajor, realMinor, realBuild;
+#ifdef MS_DESKTOP
     HANDLE hKernel32;
     wchar_t kernel32_path[MAX_PATH];
     LPVOID verblock;
     DWORD verblock_size;
+#endif
 
     ver.dwOSVersionInfoSize = sizeof(ver);
     if (!GetVersionExW((OSVERSIONINFOW*) &ver))
@@ -1493,6 +1495,7 @@
     realMinor = ver.dwMinorVersion;
     realBuild = ver.dwBuildNumber;
 
+#ifdef MS_DESKTOP
     // GetVersion will lie if we are running in a compatibility mode.
     // We need to read the version info from a system file resource
     // to accurately identify the OS version. If we fail for any reason,
@@ -1514,6 +1517,7 @@
         }
         PyMem_RawFree(verblock);
     }
+#endif
     PyStructSequence_SET_ITEM(version, pos++, Py_BuildValue("(kkk)",
         realMajor,
         realMinor,
